---
title: "Take-Home Exercise 2"
author: "Dew Stella Chan"
format: html
editor: visual
date: "Septemeber 27, 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
  warning: false
---

This page documents the codes and the analysis performed for Take Home Exercise 02.

The objectives of this exercise is to discover:

-   If the key indicators of tourism economy of Thailand are independent from space and space and time.

-   If the tourism economy is indeed spatial and spatio-temporal dependent, then, you would like to detect where are the clusters and outliers, and the emerging hot spot/cold spot areas.

Since tourism data used in this assignment covers, Pre, During and Post COVID-19 Pandemic period, the focus of this assignments will be on the foreign tourists related indicators from 2019 to 2023.

## Loading of Libraries

Due to the exploration of Geo spatial techniques, more packages were loaded to facilitates the different techniques used.

```{r}
pacman::p_load(sf, sp, sfdep, raster, spatstat, tmap, tidyverse, lubridate, readxl, spNetwork, plotly, tidyverse, Kendall,  knitr, spdep, patchwork)
set.seed(1234) #set seed to ensure the result is consistent
```

## Data preparation and Transformation

### Loading of Thailand - Subnational Administrative Boundaries

This assignment focuses on the analysis of tourism related on foreigners indicators on Province level of the Kingdom of Thailand.

The [Thailand - Subnational Administrative Boundaries](https://data.humdata.org/dataset/cod-ab-tha?) at HDX is used for the analysis.

```{r}
#|eval: false
SAB_1 = st_read(dsn = "data", layer = "tha_admbnda_adm1_rtsd_20220121")%>%
  st_transform(crs = 32647)
```

#### Writing and Reading the Province data to rds folder

```{r}
write_rds(SAB_1,"data/rds/SAB_1.rds")
#to save the file to rds
```

```{r}
#re-reading the acc file to the environments
SAB_1<-read_rds("data/rds/SAB_1.rds")
```

### Loading and preparation of Thailand Tourism Statistics

The [Thailand Domestic Tourism Statistics](https://www.kaggle.com/datasets/thaweewatboy/thailand-domestic-tourism-statistics) at Kaggle is used for this analysis. This section show the code for data preparation and transformation of theThailand Toursim Statistics.

```{r}
Tour_data <- read_csv("data/thailand_domestic_tourism_2019_2023_ver2.csv")
```

Standardizing the Province Names with the Thailand Subnational Administrative Boundaries.

```{r}
Tour_data <- Tour_data %>%
  mutate(province_eng = case_when(
    province_eng == "Buriram" ~ "Buri Ram",
    province_eng == "Chainat" ~ "Chai Nat",
    province_eng == "Chonburi" ~ "Chon Buri",
    province_eng == "Lopburi" ~ "Lop Buri",
    province_eng == "Nong Bua Lamphu" ~ "Nong Bua Lam Phu",
    province_eng == "Phang Nga" ~ "Phangnga",
    province_eng == "Prachinburi" ~ "Prachin Buri",
    province_eng == "Sisaket" ~ "Si Sa Ket",
    TRUE ~ province_eng
  ))

Tour_data <-rename(Tour_data, ADM1_EN = province_eng, Date_tour = date )
```

##### Writing and Reading the data in Tourism Statistics to rds folder

```{r}
write_rds(Tour_data,"data/rds/Tour_data.rds")
#to save the file to rds
```

```{r}
Tour_data<-read_rds("data/rds/Tour_data.rds")
#re-reading the acc file to the environments
```

#### Data Transformation

Transform tour data from long table into a table with the 8 different indicators in the variables column into individual column for data analysis.

```{r}
tour_data_wide <- pivot_wider(Tour_data, names_from = "variable", values_from = "value")
write_rds(tour_data_wide,"data/rds/tour_data_wide.rds")
```

##### Reading the wide data in Tourism Statistics from rds folder:

```{r}
#re-reading the acc file to the environments
tour_data_wide<-read_rds("data/rds/tour_data_wide.rds")
```

#### Joining the aspatial long data to geospatial data:

The aspatial data was joined to geospatial data using the column named "ADM1_EN" which consist of the province name of the Kingdom of Thailand.

```{r}
SAB1_tour_wide <- left_join(SAB_1, tour_data_wide)
write_rds(SAB1_tour_wide,"data/rds/SAB1_tour_wide.rds")
```

##### Reading the joined aspatial and geospatial data from rds folder:

```{r}
SAB1_tour_wide<-read_rds("data/rds/SAB1_tour_wide.rds")
```

### To derive foreign related spending for the study period.

As mentioned earlier, the focus of this analysis is on indicators related to the revenue generated from foreign tourism. Hence the main variables used for this analysis are:

-   Total revenue generated from Foreign Tourists (Sum of Revenue_foreign ) from the Period of 2019 to 2023 by provinces.

-   Total number of foreign tourists (sum of no_tourist_foreign) from the Period of 2019 to 2023 by provinces.

-   Amount of Revenue generated by per Tourist (Amt_rev_per_for_tourist). This indicator is derived using the above using above two indicators, sum of Revenue_foreign divided by sum of no_tourist_foreign. This indicator will highlight the provinces are attracting foreign tourists with higher spending power.

    The 3rd indicator is important for policy planning. In the context of the COVID-19, it is important for policy maker to be aware of the the province with higher spending foreign tourist. The Thai government can use this findings to isolate the area of Thailand to open up for foreign tourists and implement movement restriction measures if there is another pandemic were to occur. This will help policy measures to plan and develop plans to mitigate the impact of the pandemic on the economy and perform long term planning for a more pandemic resistance tourism industry in Thailand.

```{r}
total_for_prov<- tour_data_wide %>%
  group_by(ADM1_EN) %>%
  summarize(total_for_revenue = sum(revenue_foreign), total_no_for_tourist= sum(no_tourist_foreign))%>%
  mutate(Amt_rev_per_for_tourist= (total_for_revenue /total_no_for_tourist))

write_rds(total_for_prov,"data/rds/total_for_prov.rds")
```

The following code block is to join the as

```{r}
SAB_1_total_for_prov<- left_join(SAB_1, total_for_prov)
write_rds(SAB_1_total_for_prov,"data/rds/SAB_1_total_for_prov.rds")
```

##### To read the joined data from SAB_1 layer rds folder.

```{r}
SAB_1_total_for_prov<-read_rds("data/rds/SAB_1_total_for_prov.rds")
```

##### Preparation Thai_total_for_prov layer rds folder.

```{r}
Thai_total_for_prov <- subset(SAB_1_total_for_prov , 
                              select = c("Shape_Leng", "Shape_Area", 
                                        "ADM1_EN","date", "total_for_revenue", 
                                        "total_no_for_tourist",
                                        "Amt_rev_per_for_tourist", "geometry"))
write_rds(Thai_total_for_prov,"data/rds/Thai_total_for_prov.rds")
```

```{r}
Thai_total_for_prov<-read_rds("data/rds/Thai_total_for_prov.rds")
```

## Visualising year 2019 to 2023 by Variables

Total Revenue from foreign

```{r}
# Create the map
tmap_mode("plot")
equal_TotRev <- tm_shape(Thai_total_for_prov) +
  tm_fill("total_for_revenue",
           style = "quantile",
           palette = "Blues",
           title = "Total Revenue ") +
  tm_layout(main.title = "Equal quantile Distribution of Total Foreign Revenue by Provinces 2019 to 2023",
            main.title.position = "center",
            main.title.size = 0.6,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar()


quantile_TotRev<- tm_shape(Thai_total_for_prov) +
  tm_fill("total_for_revenue",
           style = "equal",
           palette = "Blues",
           title = "Total Revenue") +
  tm_layout(main.title = "Equal Interval of Total Foreign Revenue by Provinces 2019 to 2023",
            main.title.position = "center",
            main.title.size = 0.6,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar()


tmap_arrange(equal_TotRev, 
             quantile_TotRev, 
             asp=1, 
             ncol=2)

```

Amount of Foregin Tourist Spending.

```{r}
# Create the map
tmap_mode("plot")
equal_nofor <- tm_shape(Thai_total_for_prov) +
  tm_fill("total_no_for_tourist",
           style = "quantile",
           palette = "Blues",
           title = "Total no. of Foreign Tourist") +
  tm_layout(main.title = "Equal quantile Distribution of Total no. of Foreign Tourist by Provinces 2019 to 2023",
            main.title.position = "center",
            main.title.size = 0.6,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar()


quantil_nofor<- tm_shape(Thai_total_for_prov) +
  tm_fill("total_no_for_tourist",
           style = "equal",
           palette = "Blues",
           title = "Total no. of Foreign Tourist") +
  tm_layout(main.title = "Equal Interval of Total no. of Foreign Tourist by Provinces 2019 to 2023",
            main.title.position = "center",
            main.title.size = 0.6,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar()


tmap_arrange(equal_nofor, 
             quantil_nofor, 
             asp=1, 
             ncol=2)

```

```{r}
# Create the map
tmap_mode("plot")
equal_Amt <- tm_shape(Thai_total_for_prov) +
  tm_fill("Amt_rev_per_for_tourist",
           style = "quantile",
           palette = "Blues",
           title = "Amount of reveune per foreign Touristt") +
  tm_layout(main.title = "Equal quantile Distribution of Amount of reveune per foreign Touristby Provinces 2019 to 2023",
            main.title.position = "center",
            main.title.size = 0.6,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar()


quantil_Amt<- tm_shape(Thai_total_for_prov) +
  tm_fill("Amt_rev_per_for_tourist",
           style = "equal",
           palette = "Blues",
           title = "Amount of reveune per foreign Tourist") +
  tm_layout(main.title = "Equal Interval of Amount of reveune per foreign Tourist by Provinces 2019 to 2023",
            main.title.position = "center",
            main.title.size = 0.6,
            legend.height = 0.45,
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar()


tmap_arrange(equal_Amt, 
             quantil_Amt, 
             asp=1, 
             ncol=2)

```

# Analyising if Tourist hotspot is related to space

To start of our analysis we will start by analysing if the tourist hotspot is related spatially.

given that phunket is a offshore island and has the one of the top 3 provicnes, hence contigunity matrix will not be suitable, we will need to use distance based matrix.

```{r}
top_3_revenue <- Thai_total_for_prov %>%
  arrange(desc(total_for_revenue)) %>%
  head(3)

top_3_tourists <- Thai_total_for_prov %>%
  arrange(desc(total_no_for_tourist)) %>%
  head(3)

top_3_revenue_per_tourist <- Thai_total_for_prov %>%
  arrange(desc(Amt_rev_per_for_tourist)) %>%
  head(3)

print(top_3_revenue)
print(top_3_tourists)
print(top_3_revenue_per_tourist)
```

## Calculating using the distance based matrix:

### Fixed Distance Matrix:

```{r}
# Assuming Thai_total_for_pro has a geometry column in a projected CRS
Thai_total_for_prov <- st_transform(Thai_total_for_prov, crs = 4326) # WGS84 CRS

longitude <- map_dbl(Thai_total_for_prov$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(Thai_total_for_prov$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)
head(coords)
```

```{r}
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

```{r}
Thai_total_for_prov$ADM1_EN[match(max(k1dists), k1dists)]
```

```{r}
wm_d111 <- dnearneigh(coords, 0, 111, longlat = TRUE) #based on the max distance from the fix distance neigh
wm_d111
```

```{r}
str(wm_d111)
```

```{r}
table(Thai_total_for_prov$ADM1_EN, card(wm_d111))
```

```{r}
n_comp <- n.comp.nb(wm_d111)
n_comp$nc
```

```{r}
table(n_comp$comp.id)
```

```{r}
par(mfrow=c(1,2))
plot(Thai_total_for_prov$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(Thai_total_for_prov$geometry, border="lightgrey", main="Distance link")
plot(wm_d111, coords, add=TRUE, pch = 19, cex = 0.6)
```

### Adaptive Distanace weight martix

Examining if Adpative distance weight martrix will be more suitable for the Analysis:

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

```{r}
str(knn6)
```

### Plotting Adaptive Distance-based Neighbours

```{r}

par(mfrow=c(1,2))
plot(Thai_total_for_prov$geometry, border="lightgrey",main="6 nearest neighbours")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

plot(Thai_total_for_prov$geometry, border="lightgrey", main="Distance link")
plot(wm_d111, coords, add=TRUE, pch = 19, cex = 0.6)

```

### Weights based on IDW

```{r}
dist <- nbdists(wm_d111, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

### Row-Standardised Weights martix

```{r}
rswm_d111 <- nb2listw(wm_d111, style="W", zero.policy = TRUE)
rswm_d111
```

```{r}
rswm_d111$weights[10]
```

### a row standardised distance weight matrix by using the code chunk below.

```{r}
rswm_ids <- nb2listw(wm_d111, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r}
rswm_ids$weights[1]
```

```{r}
summary(unlist(rswm_ids$weights))
```

## Spatial lag with row-standardized weights

Finally, we’ll compute the average neighbor GDPPC value for each polygon. These values are often referred to as spatially lagged values.

```{r}
Total_rev.lag <- lag.listw(rswm_d111, Thai_total_for_prov$total_for_revenue)
Total_rev.lag
```

```{r}
nb1 <- wm_d111[[1]]
nb1 <- Thai_total_for_prov$total_for_revenue[nb1]
nb1
```

```{r}
lag.list <- list(Thai_total_for_prov$ADM1_EN, lag.listw(rswm_d111, Thai_total_for_prov$total_for_revenue))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("ADM1_EN", "lag.total_for_revenue")
Thai_total_for_prov<- left_join(Thai_total_for_prov,lag.res)
```

```{r}
lag.list <- list(Thai_total_for_prov$ADM1_EN, lag.listw(rswm_d111,Thai_total_for_prov$total_no_for_tourist))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("ADM1_EN", "lag.total_no_for_tourist")
Thai_total_for_prov<- left_join(Thai_total_for_prov,lag.res)
```

```{r}
lag.list <- list(Thai_total_for_prov$ADM1_EN, lag.listw(rswm_d111,Thai_total_for_prov$Amt_rev_per_for_tourist))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("ADM1_EN", "lag.Amt_rev_per_for_tourist")
Thai_total_for_prov<- left_join(Thai_total_for_prov,lag.res)
```

```{r}
head(Thai_total_for_prov)
```

```{r}
Total_rev <- qtm(Thai_total_for_prov, "total_no_for_tourist")
lag_Total_rev <- qtm(Thai_total_for_prov, "lag.total_no_for_tourist")
tmap_arrange(Total_rev, lag_Total_rev, asp=1, ncol=2)
```

```{r}
Total_rev <- qtm(Thai_total_for_prov, "Amt_rev_per_for_tourist")
lag_Total_rev <- qtm(Thai_total_for_prov, "lag.Amt_rev_per_for_tourist")
tmap_arrange(Total_rev, lag_Total_rev, asp=1, ncol=2)
```

```{r}
Total_rev <- qtm(Thai_total_for_prov, "total_for_revenue")
lag_Total_rev <- qtm(Thai_total_for_prov, "lag.total_for_revenue")
tmap_arrange(Total_rev, lag_Total_rev, asp=1, ncol=2)
```

###Computing Global Moran’ I

Moran’s I statistical test was pefromed by using moran.test() of spdep. Moran’s I describe how features differ from the values in the study area as a whole. The Moran I statistic ranges from -1 to 1. If the Moran I is:

positive (I\>0): Clustered, observations tend to be similar

negative (I\<0): Disperse, observations tend to be dissimilar

approximately zero: observations arranged randomly over space

#### For Total Revenue from Foregin.

```{r}
moran.test(Thai_total_for_prov$total_for_revenue, 
           listw=rswm_d111, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

The code below noted that the p-value is less than significant level at 0.05. Hence there is no relationship between the code.

```{r}

bperm_tot = moran.mc(Thai_total_for_prov$total_for_revenue, 
         listw = rswm_d111,
         nsim = 9999,
         zero.policy = TRUE,
         na.action = na.omit)
bperm_tot

```

```{r}
moran.test(Thai_total_for_prov$total_no_for_tourist, 
           listw=rswm_d111, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

```{r}

bperm_noFor = moran.mc(Thai_total_for_prov$total_no_for_tourist, 
         listw = rswm_d111,
         nsim = 9999,
         zero.policy = TRUE,
         na.action = na.omit)
bperm_noFor

```

```{r}
moran.test(Thai_total_for_prov$Amt_rev_per_for_tourist, 
           listw=rswm_d111, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

```{r}
bperm_Amt = moran.mc(Thai_total_for_prov$Amt_rev_per_for_tourist, 
         listw = rswm_d111,
         nsim = 9999,
         zero.policy = TRUE,
         na.action = na.omit)
bperm_Amt

```

The Moran's I statistic of 0.31624 suggests a moderate positive spatial autocorrelation. This means that provinces in Thailand with higher revenue per tourist tend to be clustered together.

The statistical report on shows that the p-value is larger than alpha value of 0.05. Hence, we dont have statistical evidence to reject the null hypothesis that the spatial distribution of total foreign spedning in Thailand may resemble random distribution (i.e. independent from spatial). Because the Moran’s I statistics is lesser than 0. We can infer that the spatial distribution shows sign of randomness and is not related to spatial.

#### to be plotted later

```{r}
df <- as.data.frame(bperm_Amt$res)
colnames(df) <- c("Simulated Moran's I")

moran_amt <- ggplot(df, aes(x=`Simulated Moran's I`)) + 
  geom_histogram(color = "black", fill = "grey", bins = 25) +
  xlim(-0.1,0.6) + 
  ylab('Frequency') + 
  geom_vline(xintercept = 0, color = 'red') +
  geom_vline(xintercept =  0.316242836 , color = 'blue') + 
  ggtitle("Histogram of Monte Carlo Simulated \nMoran's I (Amount Spent per foregin tourist") +
  theme(plot.title = element_text(size = 10, hjust = 0.5)) +
  annotate("text", x = 0.35, y = 410, label = "Actual Moran's I", color = 'blue') 

moran_amt

```

```{r}
geary.test(Thai_total_for_prov$total_for_revenue, listw = rswm_d111)
```

```{r}
geary.test(Thai_total_for_prov$Amt_rev_per_for_tourist, listw = rswm_d111)
```

```{r}
geary.test(Thai_total_for_prov$total_no_for_tourist, listw = rswm_d111)
```

Computing Monte Carlo Geary’s C

```{r}
bperm_G_Amt = geary.mc(Thai_total_for_prov$Amt_rev_per_for_tourist,
                 listw = rswm_d111,
                 nsim = 999)
bperm_G_Amt
```

```{r}
moran_corr_Amt<- sp.correlogram(knn6, #non-weighted spatial weights
                          Thai_total_for_prov$Amt_rev_per_for_tourist,
                          order = 6,
                          method = 'I', #Moran's I
                          style = 'W') #weighed
plot(moran_corr_Amt)
print(moran_corr_Amt)
```

#### 10.4.3 Computing local Moran’s I

```{r}
fips <- order(Thai_total_for_prov$Amt_rev_per_for_tourist)
localMI <- localmoran(Thai_total_for_prov$Amt_rev_per_for_tourist, rswm_d111)
head(localMI)
```

```{r}
printCoefmat(data.frame(
  localMI[fips,], 
  row.names=Thai_total_for_prov$ADM1_EN[fips]),
  check.names=FALSE)
```

```{r}
Thai_total_for_prov.localMI <- cbind(Thai_total_for_prov,localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

```{r}
tm_shape(Thai_total_for_prov.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty",
          palette = "RdBu",
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)
```

```{r}
tm_shape(Thai_total_for_prov.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)
```

```{r}
nci <- moran.plot(Thai_total_for_prov$lag.Amt_rev_per_for_tourist, rswm_d111,
                  labels=as.character(Thai_total_for_prov$ADM1_EN), 
                  xlab="Total Revenue 2019 to 2024", 
                  ylab="Total Revenue 2019 to 2024")
```

#Lisa Map:

```{r}
#Step 1
quadrant <- vector(mode="numeric",length=nrow(localMI))
#Step 2
Thai_total_for_prov$Amt_rev_per_for_tourist <- lag.listw(rswm_d111, Thai_total_for_prov$Amt_rev_per_for_tourist)
DV <- Thai_total_for_prov$Amt_rev_per_for_tourist - mean(Thai_total_for_prov$Amt_rev_per_for_tourist)     
#Step 3
LM_I <- localMI[,1] - mean(localMI[,1])
#Step 4
signif <- 0.05
#Step 5
quadrant[DV <0 & LM_I>0] <- 1 #low-low
quadrant[DV >0 & LM_I<0] <- 2 #high-low
quadrant[DV <0 & LM_I<0] <- 3 #low-high
quadrant[DV >0 & LM_I>0] <- 4 #high-high
#Step 6
quadrant[localMI[,5]>signif]<- 0
```

```{r}
Thai_total_for_prov.localMI$quadrant <- quadrant
colors <- c("#ffffff", "#2c7bb6", "#abd9e9", "#fdae61", "#d7191c")
clusters <- c("insignificant", "low-low", "low-high", "high-low", "high-high")

LISAmap <- tm_shape(Thai_total_for_prov.localMI) +
  tm_fill(col = "quadrant", 
          style = "cat", 
          palette = colors[c(sort(unique(quadrant)))+1], 
          labels = clusters[c(sort(unique(quadrant)))+1],
          popup.vars = c("")) +
  tm_view(set.zoom.limits = c(11,17)) +
  tm_borders(alpha=0.5)

tmap_arrange(Total_rev, LISAmap, 
             asp=1, ncol=2)
```

We can also include the local Moran’s I map and p-value map as shown below for easy comparison.

## 5.2.2 Hot Spot Area Analysis

```{r}
knn_lw <- nb2listw(knn6,
                   style = "B",
                   zero.policy = TRUE)
knn_lw
```

## Gi statistics using fixed distance

```{r}
fips <- order(Thai_total_for_prov$ADM1_EN)
gi.fixed <- localG(Thai_total_for_prov$Amt_rev_per_for_tourist, knn_lw)
gi.fixed
```

```{r}
Thai_total_for_prov.gi <- cbind(Thai_total_for_prov, as.matrix(gi.fixed)) %>%
  rename(gstat_fixed = as.matrix.gi.fixed.)
```

```{r}
Gimap <-tm_shape(Thai_total_for_prov.gi) +
  tm_fill(col = "gstat_fixed", 
          style = "pretty",
          palette="-RdBu",
          title = "local Gi") +
  tm_borders(alpha = 0.5)
tmap_arrange(Total_rev, Gimap, asp=1, ncol=2)
```

### Gi statistics using adaptive distance

```{r}
fips <- order(Thai_total_for_prov$ADM1_EN)
gi.adaptive <- localG(Thai_total_for_prov$Amt_rev_per_for_tourist, knn_lw)
Thai_total_for_pro_adp.gi <- cbind(Thai_total_for_prov, as.matrix(gi.adaptive)) %>%
  rename(gstat_adaptive = as.matrix.gi.adaptive.)
```

```{r}
Gimap_adap <-tm_shape(Thai_total_for_pro_adp.gi) +
  tm_fill(col = "gstat_adaptive", 
          style = "pretty",
          palette="-RdBu",
          title = "local Gi") +
  tm_borders(alpha = 0.5)

tmap_arrange(Gimap_adap, Gimap, asp=1, ncol=2)
```

## Time Series

```{r}
 Tourdata_st <- spacetime(tour_data_wide, SAB_1,
                      .loc_col = "ADM1_EN",
                      .time_col = "Date_tour")
```

```{r}
is_spacetime_cube(Tourdata_st)
```

### Emergering Hotspot

```{r}
ehsa <- emerging_hotspot_analysis(
  x = Tourdata_st, 
  .var = "revenue_foreign", 
  k = 1, 
  nsim = 99
)
```

```{r}
write_rds(ehsa ,"data/rds/ehsa.rds")
```

```{r}
ehsa <-read_rds("data/rds/ehsa.rds")
```

```{r}
Thai_ehsa <- SAB_1 %>%
  left_join(ehsa,
            by = join_by(ADM1_EN== location))
```

```{r}
write_rds(Thai_ehsa ,"data/rds/Thai_ehsa.rds")
```

```{r}
Thai_ehsa<-read_rds("data/rds/Thai_ehsa.rds")
```

```{r}
ehsa_sig <- Thai_ehsa  %>%
  filter(p_value < 0.05)
tmap_mode("plot")
tm_shape(Thai_ehsa) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(ehsa_sig) +
  tm_fill("classification") + 
  tm_borders(alpha = 0.4)
```
